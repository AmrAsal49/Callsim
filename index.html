<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Call Simulator Comcast SMB wave. 24</title>
  <style>
    :root {
      --bg-main: #0a0a0a;
      --bg-container: #1a1a1a;
      --bg-message-ai: #2d2d2d;
      --bg-message-user: #1a6cd0;
      --text-main: #ffffff;
      --text-secondary: #a0a0a0;
      --accent-color: #1a6cd0;
      --success-color: #10b981;
      --error-color: #ef4444;
      --quality-bg: #2d2d2d;
      --quality-border: #444;
      --quality-score-good: #10b981;
      --quality-score-bad: #ef4444;
      --quality-score-neutral: #f59e0b;
      color-scheme: dark;
    }

    body {
      font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--bg-main);
      color: var(--text-main);
      margin: 0;
      padding: 0;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .main-layout {
      flex: 1;
      max-width: 1200px;
      margin: 1rem auto;
      width: 100%;
      display: flex;
      gap: 1rem;
      height: calc(100vh - 2rem);
      flex-direction: row;
    }

    .container {
      flex: 2.5;
      display: flex;
      flex-direction: column;
      position: relative;
      background: var(--bg-container);
      box-shadow: 0 2px 12px rgba(0,0,0,0.3);
      border-radius: 12px;
      backdrop-filter: blur(10px);
    }

    .quality-panel-wrapper {
      flex: 1.5;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .quality-panel {
      background: var(--quality-bg);
      box-shadow: 0 2px 12px rgba(0,0,0,0.3);
      border-radius: 12px;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      border: 1px solid var(--quality-border);
      flex: 2;
    }

    .quality-panel h2 {
      font-size: 1.3rem;
      font-weight: 600;
      color: var(--text-main);
      margin-bottom: 1rem;
      text-align: center;
    }

    .quality-feedback-content {
      flex: 1;
      overflow-y: auto;
      padding-right: 0.5rem;
    }

    .quality-comment {
      background: rgba(255,255,255,0.05);
      border-left: 4px solid var(--quality-score-neutral);
      padding: 0.8rem;
      border-radius: 8px;
      margin-bottom: 0.8rem;
      font-size: 0.9rem;
      line-height: 1.4;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      position: relative;
    }

    .quality-comment.good { border-color: var(--quality-score-good); }
    .quality-comment.bad { border-color: var(--quality-score-bad); }

    .quality-comment strong {
      color: var(--text-main);
    }

    .quality-feedback-content::-webkit-scrollbar {
      width: 6px;
    }

    .quality-feedback-content::-webkit-scrollbar-track {
      background: var(--quality-bg);
    }

    .quality-feedback-content::-webkit-scrollbar-thumb {
      background: rgba(255,255,255,0.2);
      border-radius: 3px;
    }

    .quality-feedback-content::-webkit-scrollbar-thumb:hover {
      background: rgba(255,255,255,0.3);
    }

    .quality-info-btn {
      position: absolute;
      top: 0.5rem;
      right: 0.5rem;
      background: none;
      border: none;
      color: var(--text-secondary);
      font-size: 0.9rem;
      cursor: pointer;
      opacity: 0.7;
      transition: opacity 0.2s, color 0.2s;
    }
    .quality-info-btn:hover {
      opacity: 1;
      color: var(--accent-color);
    }

    @media (max-width: 768px) {
      .main-layout {
        flex-direction: column;
        height: auto;
        margin: 0.5rem;
      }
      .container, .quality-panel, .quality-panel-wrapper {
        flex: none;
        width: auto;
        margin-bottom: 1rem;
      }
      .quality-panel, .s4-progress-panel {
        height: auto;
      }
    }

    .header {
      background: var(--accent-color);
      color: var(--text-main);
      padding: 1rem;
      text-align: center;
      position: sticky;
      top: 0;
      z-index: 100;
      border-top-left-radius: 12px;
      border-top-right-radius: 12px;
      backdrop-filter: blur(8px);
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }

    .header h1 {
      margin: 0;
      font-size: 1.5rem;
      font-weight: 600;
      letter-spacing: -0.02em;
    }

    .status {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }

    .status-indicator {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #6b7280;
    }

    .status-indicator.listening {
      background: #10b981;
      animation: pulse 1.5s infinite;
    }

    .status-indicator.speaking {
      background: #ef4444;
      animation: pulse 1.5s infinite;
    }

    .silence-timer {
      font-size: 0.9rem;
      color: var(--text-secondary);
      display: none;
    }

    .silence-timer.active {
      display: inline;
    }

    .chat-container {
      flex: 1;
      overflow-y: auto;
      padding: 1rem;
      background: var(--bg-container);
    }

    .messages {
      display: flex;
      flex-direction: column;
      gap: 0.8rem;
      padding-bottom: 1rem;
    }

    .message {
      max-width: 70%;
      padding: 0.8rem 1rem;
      border-radius: 1rem;
      position: relative;
      white-space: pre-wrap;
      word-wrap: break-word;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      animation: fadeIn 0.3s ease-in;
      font-size: 0.95rem;
      line-height: 1.5;
      transition: all 0.2s ease-out;
    }

    .message.transcription:not(.sent)::after {
      content: '';
      display: inline-block;
      width: 4px;
      height: 4px;
      background: rgba(255,255,255,0.7);
      border-radius: 50%;
      margin-left: 4px;
      vertical-align: middle;
      animation: blink 1s infinite;
    }

    .message.user {
      align-self: flex-end;
      background: var(--bg-message-user);
      color: white;
      border-bottom-right-radius: 0.4rem;
      margin-left: 2rem;
    }

    .message.assistant {
      align-self: flex-start;
      background: var(--bg-message-ai);
      color: var(--text-main);
      border-bottom-left-radius: 0.4rem;
      margin-right: 2rem;
      border: 1px solid rgba(255,255,255,0.1);
    }

    .message .sender-name {
      font-weight: bold;
      margin-bottom: 0.2rem;
      display: block;
      color: rgba(255,255,255,0.7);
      font-size: 0.85rem;
    }
    .message.user .sender-name {
      text-align: right;
      color: rgba(255,255,255,0.8);
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4); }
      70% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
      100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
    }

    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0; }
    }

    .chat-container::-webkit-scrollbar, .quality-feedback-content::-webkit-scrollbar {
      width: 8px;
    }

    .chat-container::-webkit-scrollbar-track, .quality-feedback-content::-webkit-scrollbar-track {
      background: var(--bg-container);
    }

    .chat-container::-webkit-scrollbar-thumb, .quality-feedback-content::-webkit-scrollbar-thumb {
      background: rgba(255,255,255,0.2);
      border-radius: 4px;
    }

    .chat-container::-webkit-scrollbar-thumb:hover, .quality-feedback-content::-webkit-scrollbar-thumb:hover {
      background: rgba(255,255,255,0.3);
    }

    .controls {
      padding: 1rem;
      background: var(--bg-container);
      border-top: 1px solid rgba(255,255,255,0.1);
      display: flex;
      flex-direction: column;
      gap: 0.8rem;
      border-bottom-left-radius: 12px;
      border-bottom-right-radius: 12px;
    }

    .button-group {
      display: flex;
      gap: 1rem;
      justify-content: center;
    }

    .btn {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.8rem 1.2rem;
      border: none;
      border-radius: 24px;
      color: white;
      cursor: pointer;
      font-size: 1rem;
      transition: all 0.2s;
      font-weight: 500;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      backdrop-filter: blur(4px);
    }

    .btn-primary {
      background: var(--accent-color);
    }

    .btn-primary:hover:not(:disabled) {
      background: #006cbd;
      transform: translateY(-1px);
    }

    .btn-danger {
      background: #ef4444;
    }

    .btn-danger:hover:not(:disabled) {
      background: #dc2626;
      transform: translateY(-1px);
    }

    .btn-secondary {
      background: #6b7280;
    }

    .btn-secondary:hover:not(:disabled) {
      background: #4b5563;
      transform: translateY(-1px);
    }

    .btn:disabled {
      background: #cccccc;
      cursor: not-allowed;
      opacity: 0.7;
    }

    .btn .button-icon {
      font-size: 1.2rem;
    }

    .manual-input {
      width: 100%;
      border-radius: 6px;
      padding: 0.6rem;
      font-size: 1rem;
      resize: vertical;
      background: var(--bg-container);
      color: var(--text-main);
      border: 1px solid var(--quality-border);
      font-family: inherit;
    }

    .manual-input:focus {
      outline: 2px solid var(--accent-color);
    }

    .settings {
      display: flex;
      gap: 1rem;
      justify-content: center;
      margin-top: 0.5rem;
    }

    .settings select {
      padding: 0.5rem;
      border-radius: 6px;
      border: 1px solid #444;
      background: #181c22;
      color: #fff;
      font-size: 0.9rem;
    }

    .modal {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
    }
    .modal.show {
      opacity: 1;
      visibility: visible;
    }
    .modal-content {
      background: #23272f;
      color: #fff;
      border-radius: 10px;
      padding: 2rem;
      min-width: 320px;
      max-width: 90vw;
      box-shadow: 0 4px 32px rgba(0,0,0,0.4);
      display: flex;
      flex-direction: column;
      gap: 1rem;
      position: relative;
    }
    .modal-content label {
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
      font-size: 1rem;
    }
    .modal-content input[type="text"],
    .modal-content input[type="number"],
    .modal-content select,
    .modal-content textarea {
      margin-top: 0.2rem;
      border-radius: 6px;
      border: 1px solid #444;
      background: #181c22;
      color: #fff;
      padding: 0.4rem 0.6rem;
      font-size: 1rem;
    }
    .modal-content textarea {
      resize: vertical;
    }
    .modal-actions {
      display: flex;
      gap: 1rem;
      justify-content: flex-end;
    }
    .modal-actions button {
      background: var(--accent-color);
      color: #fff;
      border: none;
      border-radius: 6px;
      padding: 0.5rem 1rem;
      font-size: 1rem;
      cursor: pointer;
      transition: background 0.2s;
    }
    .modal-actions button:hover {
      background: #0e4a8a;
    }
    .modal-close-button {
      position: absolute;
      top: 10px;
      right: 10px;
      background: none;
      border: none;
      font-size: 1.5rem;
      color: var(--text-secondary);
      cursor: pointer;
      transition: color 0.2s;
    }
    .modal-close-button:hover {
      color: var(--text-main);
    }

    .s4-progress-panel {
      background: var(--quality-bg);
      box-shadow: 0 2px 12px rgba(0,0,0,0.3);
      border-radius: 12px;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      border: 1px solid var(--quality-border);
      flex: 1;
    }

    .s4-progress-panel h2 {
      font-size: 1.3rem;
      font-weight: 600;
      color: var(--text-main);
      margin-bottom: 0.5rem;
      text-align: center;
    }

    .s4-phase {
      display: flex;
      align-items: center;
      gap: 0.8rem;
      padding: 0.6rem 0.8rem;
      background: rgba(255,255,255,0.05);
      border-radius: 8px;
      transition: background 0.3s ease;
    }

    .s4-phase.active {
      background: rgba(26, 108, 208, 0.2);
      border: 1px solid var(--accent-color);
    }
    .s4-phase.completed {
      background: rgba(16, 185, 129, 0.2);
      border: 1px solid var(--success-color);
    }

    .s4-indicator-bulb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background-color: #555;
      box-shadow: 0 0 5px rgba(0,0,0,0.5);
      transition: background-color 0.3s ease, box-shadow 0.3s ease;
    }

    .s4-phase.active .s4-indicator-bulb {
      background-color: var(--accent-color);
      box-shadow: 0 0 8px var(--accent-color), 0 0 15px var(--accent-color);
    }
    .s4-phase.completed .s4-indicator-bulb {
      background-color: var(--success-color);
      box-shadow: 0 0 8px var(--success-color), 0 0 15px var(--success-color);
    }

    .s4-phase-content {
      flex: 1;
    }

    .s4-phase-title {
      font-weight: 600;
      color: var(--text-main);
      font-size: 1rem;
    }

    .s4-phase-description {
      font-size: 0.85rem;
      color: var(--text-secondary);
      margin-top: 0.2rem;
    }

    .modal-buttons {
      position: absolute;
      top: 1rem;
      right: 1rem;
      z-index: 200;
      display: flex;
      gap: 0.5rem;
    }
  </style>
</head>
<body>
  <div class="main-layout">
    <div class="quality-panel-wrapper">
      <div class="quality-panel">
        <h2>Quality Feedback</h2>
        <div class="quality-feedback-content" id="quality-feedback-panel">
          <div class="quality-comment">Feedback will appear here after each of your responses.</div>
        </div>
      </div>
      <div class="s4-progress-panel">
        <h2>S4 Progress</h2>
        <div id="s4-phases-container">
          <div class="s4-phase" id="s1-phase">
            <div class="s4-indicator-bulb"></div>
            <div class="s4-phase-content">
              <div class="s4-phase-title">S1: Start</div>
              <div class="s4-phase-description">Greeting, Reflect Reason, Empathize, Take Ownership, Authenticate/Set Agenda.</div>
            </div>
          </div>
          <div class="s4-phase" id="s2-phase">
            <div class="s4-indicator-bulb"></div>
            <div class="s4-phase-content">
              <div class="s4-phase-title">S2: Solve</div>
              <div class="s4-phase-description">Obtain Info/Probe, Resolve Issue, Build Value/Promote.</div>
            </div>
          </div>
          <div class="s4-phase" id="s3-phase">
            <div class="s4-indicator-bulb"></div>
            <div class="s4-phase-content">
              <div class="s4-phase-title">S3: Sell</div>
              <div class="s4-phase-description">Transition to Offer, Present Offer, Overcome Objections, Proactively Close Sale.</div>
            </div>
          </div>
          <div class="s4-phase" id="s4-phase">
            <div class="s4-indicator-bulb"></div>
            <div class="s4-phase-content">
              <div class="s4-phase-title">S4: Summarize</div>
              <div class="s4-phase-description">Summarize Actions, Close Contact, Documentation.</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container">
      <div class="header">
        <h1>Call Simulator üéß</h1>
        <div class="status">
          <div class="status-indicator" id="statusIndicator"></div>
          <span id="statusText">Ready</span>
        </div>
        <div class="silence-timer" id="silenceTimer">Auto-send in 2s</div>
      </div>
      <div class="chat-container" id="chat">
        <div class="messages">
          <div class="message assistant">
            üëã Hi! I'm your call simulator. Click "Start Conversation" to begin the call.
          </div>
        </div>
      </div>
      <div class="controls">
        <textarea id="manual-input" placeholder="Edit or type your message..." rows="2" class="manual-input"></textarea>
        <div class="button-group">
          <button class="btn btn-primary" id="startBtn">
            <span class="button-icon">üé§</span>
            <span class="button-text">Start Conversation</span>
          </button>
          <button class="btn btn-danger" id="stopBtn" disabled>
            <span class="button-icon">‚èπÔ∏è</span>
            <span class="button-text">Stop</span>
          </button>
          <button class="btn btn-secondary" id="sendBtn" disabled>
            <span class="button-icon">üì§</span>
            <span class="button-text">Send Now</span>
          </button>
        </div>
        <div class="settings">
          <select id="silenceDelay">
            <option value="1000">1s delay</option>
            <option value="2000" selected>2s delay</option>
            <option value="3000">3s delay</option>
            <option value="5000">5s delay</option>
          </select>
        </div>
      </div>
      <div class="modal-buttons">
        <button id="open-settings" class="btn btn-secondary" style="padding: 0.5rem; border-radius: 50%; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center;" title="Settings">‚öôÔ∏è</button>
        <button id="open-persona" class="btn btn-secondary" style="padding: 0.5rem; border-radius: 50%; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center;" title="Persona">üßë‚Äçüíº</button>
      </div>
    </div>
  </div>

  <div id="genericModal" class="modal">
    <div class="modal-content">
      <button class="modal-close-button" id="closeModalBtn">√ó</button>
      <h3 id="modalTitle" style="font-size: 1.2rem; font-weight: 600; margin-bottom: 1rem;"></h3>
      <div id="modalBody"></div>
      <div class="modal-actions">
        <button id="modalSaveBtn">Save</button>
        <button id="modalCancelBtn">Cancel</button>
      </div>
    </div>
  </div>

  <script src="complaints.js"></script>

  <script>
    class VoiceController extends EventTarget {
      constructor(options = {}) {
        super();
        this.config = {
          silenceDelay: options.silenceDelay || 2000,
          autoLoop: options.autoLoop !== false,
          language: options.language || 'en-US',
          voiceGender: options.voiceGender || 'female',
          speechRate: options.speechRate || 0.9,
          speechPitch: options.speechPitch || 1.0,
          speechVolume: options.speechVolume || 0.8,
          debug: options.debug || true,
          ...options
        };

        this.state = {
          isListening: false,
          isSpeaking: false,
          isProcessing: false,
          conversationActive: false,
          currentTranscription: '',
          lastUserMessage: '',
          lastAssistantMessage: '',
          isTypingManually: false,
          lastSentMessage: null,
          lastSpeechEndTime: 0,
          currentScenario: null,
          currentS4Phase: 'S1',
          chatHistory: [],
          qualityFeedbackHistory: []
        };

        this.silenceTimer = null;
        this.recognition = null;
        this.synthesis = window.speechSynthesis;
        this.currentUtterance = null;
        this.scenarios = window.COMPLAINTS_DATA || [
          {
            customerName: "Default Customer",
            initialCustomerComplaint: "I have an issue with my service.",
            customerGender: "male",
            customerTemperature: 0.7,
            customerTopK: 40,
            customerTopP: 0.8,
            customerMaxOutputTokens: 100
          }
        ];

        this.customerPersona = "You are a Comcast customer with a billing inquiry. You are slightly frustrated but polite. Respond concisely. Ensure your responses have variance and do not sound robotic.";
        this.qualityAssistantPersona = "You are an S4 Quality Assurance Specialist. Evaluate the agent's last response based on the S4 guidelines provided. Focus on Start, Solve, Sell, Summarize, and Foundational Behaviors.";
        this.flowManagerPersona = "You are a Call Flow Manager AI. Your role is to guide the agent through the S4 call flow. Based on the conversation history and the current S4 phase, provide a subtle suggestion or prompt to help the agent progress or conclude the call. Your tone should be helpful and encouraging, not critical.";

        this.S4_GUIDELINES_SUMMARY = `
S4 Universal Call Flow:
- S1: Start (Greeting, Reflect Reason, Relate/Empathize, Take Ownership, Authenticate/Set Agenda)
- S2: Solve (Obtain Info/Probe, Resolve Issue, Build Value/Promote)
- S3: Sell (Transition to Offer, Present Offer, Overcome Objections, Proactively Close Sale)
- S4: Summarize (Summarize Actions, Close Contact, Documentation)
Foundational Behaviors: Tone, Confidence, Clarity; Active Listening; Contact Management; Acknowledge/Take Responsibility; Build Rapport/Demonstrate Concern.
Scoring: Highly Effective (HE) gives more points than Meets Expectations (ME). Below Expectations (BE) gives 0 points.
Critical Failures: Auto-Fail (e.g., Rudeness, Inappropriate Transfer) results in 0 overall. Section Failure (e.g., Authentication failure) results in 0 for that section.
        `;

        this.initSpeechRecognition();
        this.initSpeechSynthesis();
        this.log('VoiceController initialized');

        if (!window.COMPLAINTS_DATA) {
          this.log("COMPLAINTS_DATA is undefined. Using fallback scenario.");
        } else {
          this.log(`COMPLAINTS_DATA loaded successfully with ${window.COMPLAINTS_DATA.length} scenarios.`);
        }
      }

      initSpeechRecognition() {
        if ('webkitSpeechRecognition' in window) {
          this.recognition = new webkitSpeechRecognition();
        } else if ('SpeechRecognition' in window) {
          this.recognition = new SpeechRecognition();
        } else {
          this.emit('error', { type: 'recognition_not_supported', message: 'Speech recognition not supported' });
          return;
        }

        this.recognition.continuous = true;
        this.recognition.interimResults = true;
        this.recognition.lang = this.config.language;
        this.recognition.maxAlternatives = 1;

        this.recognition.onstart = () => {
          this.state.isListening = true;
          this.log('Speech recognition started');
          this.emit('listening_started');
        };

        this.recognition.onresult = (event) => {
          this.handleSpeechResult(event);
        };

        this.recognition.onerror = (event) => {
          this.log(`Speech recognition error: ${event.error}`);
          this.emit('recognition_error', { error: event.error });
          if (event.error === 'no-speech' && this.config.autoLoop && !this.state.isTypingManually) {
            this.restartListening();
          }
        };

        this.recognition.onend = () => {
          this.state.isListening = false;
          this.log('Speech recognition ended');
          this.emit('listening_stopped');
          if (this.state.conversationActive && this.config.autoLoop && !this.state.isSpeaking && !this.state.isTypingManually) {
            setTimeout(() => this.startListening(), 500);
          }
        };
      }

      initSpeechSynthesis() {
        if (this.synthesis.onvoiceschanged !== undefined) {
          this.synthesis.onvoiceschanged = () => {
            this.selectVoice();
          };
        }
        this.selectVoice();
      }

      handleSpeechResult(event) {
        if (this.state.isTypingManually) {
          this.log('User typing manually - ignoring speech recognition updates');
          return;
        }

        let interimTranscript = '';
        let finalTranscript = '';
        let confidence = 0;

        for (let i = event.resultIndex; i < event.results.length; i++) {
          const transcript = event.results[i][0].transcript;
          if (event.results[i].isFinal) {
            finalTranscript += transcript;
            confidence = event.results[i][0].confidence;
          } else {
            interimTranscript += transcript;
          }
        }

        this.state.currentTranscription = finalTranscript + interimTranscript;

        this.emit('transcription_update', {
          text: this.state.currentTranscription,
          isFinal: finalTranscript.length > 0,
          interim: interimTranscript,
          confidence
        });

        if (this.state.currentTranscription) {
          this.resetSilenceTimer();
        }
      }

      startConversation() {
        this.state.conversationActive = true;
        this.state.lastSentMessage = null;
        this.state.lastSpeechEndTime = performance.now();
        this.state.chatHistory = [];
        this.state.qualityFeedbackHistory = [];
        this.state.currentS4Phase = 'S1';
        this.state.currentScenario = this.getRandomScenario();
        this.log('Conversation started with scenario:', JSON.stringify(this.state.currentScenario, null, 2));
        this.emit('conversation_started', { scenario: this.state.currentScenario });
        this.startListening();
      }

      stopConversation() {
        this.state.conversationActive = false;
        this.stopListening();
        this.stopSpeaking();
        this.clearSilenceTimer();
        this.state.isTypingManually = false;
        this.state.lastSpeechEndTime = performance.now();
        this.log('Conversation stopped');
        this.emit('conversation_stopped');
      }

      startListening() {
        if (!this.recognition) {
          this.emit('error', { type: 'no_recognition', message: 'Speech recognition not available. Check microphone permissions.' });
          return;
        }
        if (this.state.isListening || this.state.isSpeaking || this.state.isTypingManually) {
          this.log('Cannot start listening: already listening, speaking, or typing manually');
          return;
        }

        try {
          this.state.currentTranscription = '';
          this.recognition.start();
          this.log('Started listening');
        } catch (error) {
          this.log(`Failed to start recognition: ${error.message}`);
          this.emit('error', { type: 'start_listening_failed', message: 'Failed to access mic. Check permissions.' });
        }
      }

      stopListening() {
        if (this.recognition && this.state.isListening) {
          this.recognition.stop();
          this.clearSilenceTimer();
          this.log('Stopped listening');
        }
      }

      restartListening() {
        this.log('Restarting listening...');
        setTimeout(() => {
          if (this.state.conversationActive && !this.state.isSpeaking && !this.state.isTypingManually) {
            this.startListening();
          }
        }, 1000);
      }

      resetSilenceTimer() {
        if (this.state.isTypingManually) {
          return;
        }
        this.clearSilenceTimer();
        this.emit('silence_timer_reset');

        this.silenceTimer = setTimeout(() => {
          this.emit('silence_detected');
          if (this.state.currentTranscription.trim() && this.state.currentTranscription.trim() !== this.state.lastSentMessage) {
            this.processUserMessage(this.state.currentTranscription.trim());
          }
        }, this.config.silenceDelay);
      }

      clearSilenceTimer() {
        if (this.silenceTimer) {
          clearTimeout(this.silenceTimer);
          this.silenceTimer = null;
        }
      }

      async processUserMessage(message, confidence = 1.0, deadAir = 0) {
        if (!message || message === this.state.lastSentMessage) {
          this.log('Ignoring duplicate or empty message');
          return;
        }
        this.state.lastSentMessage = message;
        this.state.lastUserMessage = message;
        this.state.currentTranscription = '';
        this.state.isProcessing = true;
        this.state.isTypingManually = false;
        this.state.lastSpeechEndTime = performance.now();

        this.log(`Processing user message: "${message}" (confidence: ${confidence}, deadAir: ${deadAir}s)`);
        this.emit('user_message', { message, confidence, deadAir });

        this.stopListening();

        try {
          this.state.chatHistory.push({ role: 'user', parts: [{ text: message }] });
          await Promise.all([
            this.generateQualityFeedback(message, confidence, deadAir),
            this.generateCustomerResponse(),
            this.generateCallFlowSuggestion()
          ]);
          this.emit('processing_finished');
        } catch (error) {
          this.log(`Error processing message: ${error.message}`);
          this.emit('error', { type: 'processing_failed', message: error.message });
        } finally {
          this.state.isProcessing = false;
        }
      }

      async generateCustomerResponse() {
        const conversationContext = this.state.chatHistory.slice(-6);
        const prompt = `You are a Comcast CUSTOMER. Never respond as an agent. Always speak from the customer's point of view.
Customer Name: ${this.state.currentScenario.customerName}
Gender: ${this.state.currentScenario.customerGender}
Complaint: "${this.state.currentScenario.initialCustomerComplaint}"
Agent just said: "${this.state.lastUserMessage}"
Now respond only as the customer in a realistic, emotional tone.`;

        const response = await this.generateContent(
          conversationContext,
          prompt,
          this.state.currentScenario.customerTemperature,
          this.state.currentScenario.customerTopK,
          this.state.currentScenario.customerTopP,
          this.state.currentScenario.customerMaxOutputTokens,
          []
        );

        if (response.startsWith('Error:')) {
          this.emit('assistant_message', { message: response, sender: 'Customer AI' });
          this.log('Error generating customer response');
        } else {
          this.state.chatHistory.push({ role: 'model', parts: [{ text: response }] });
          this.emit('assistant_message', { message: response, sender: this.state.currentScenario.customerName });
          await this.speak(response, this.state.currentScenario.customerGender);
        }
      }

      async generateQualityFeedback(agentResponseText, confidence, deadAir) {
        const conversationContext = this.state.chatHistory.slice(-2);
        const prompt = `QA Persona: "${this.qualityAssistantPersona}". Evaluate the agent's last response ("${agentResponseText}") based on the S4 guidelines and foundational behaviors. Provide a score out of 100 and a brief comment. Also, identify the current S4 phase (S1, S2, S3, or S4) the conversation is in based on the agent's last response and the overall flow. S4 Guidelines: ${this.S4_GUIDELINES_SUMMARY} Include speech confidence: ${confidence.toFixed(2)}. Include dead air duration: ${deadAir.toFixed(2)}s. The response should be in JSON format: {"score": number, "comment": "string", "s4Phase": "S1|S2|S3|S4", "reasoning": "string", "suggestions": "string"}`;

        try {
          const feedbackJson = await this.generateContent(
            conversationContext,
            prompt,
            0.7, 40, 0.8, 500, []
          );
          this.log("Quality Feedback JSON:", feedbackJson);

          const cleanedFeedbackJson = feedbackJson.replace(/```json\n|\n```/g, '').trim();
          const feedback = JSON.parse(cleanedFeedbackJson);
          this.emit('quality_feedback', {
            score: feedback.score,
            comment: feedback.comment,
            details: {
              s4Phase: feedback.s4Phase,
              confidence,
              deadAir,
              reasoning: feedback.reasoning,
              suggestions: feedback.suggestions
            }
          });
          this.state.qualityFeedbackHistory.push({ score: feedback.score, comment: feedback.comment, details: { s4Phase: feedback.s4Phase, confidence, deadAir } });
          this.state.currentS4Phase = feedback.s4Phase;
        } catch (e) {
          this.log('Error parsing or generating quality feedback:', e);
          this.emit('quality_feedback', {
            score: 50,
            comment: 'Could not generate detailed quality feedback.',
            details: { confidence, deadAir }
          });
        }
      }

      async generateCallFlowSuggestion() {
        const conversationContext = this.state.chatHistory.slice(-4);
        const prompt = `Flow Manager Persona: "${this.flowManagerPersona}". You are a Call Flow Manager AI. Your role is to guide the agent through the S4 call flow. Based on the conversation history and the current S4 phase (${this.state.currentS4Phase}), provide a subtle suggestion or prompt to help the agent progress or conclude the call. Your tone should be helpful and encouraging, not critical. Suggest the next logical S4 phase or a concluding action (e.g., 'summarize the call'). If the current phase is S4 and all actions are likely complete, suggest concluding the call. Previous Quality Feedback: ${JSON.stringify(this.state.qualityFeedbackHistory)}`;

        try {
          const suggestion = await this.generateContent(
            conversationContext,
            prompt,
            0.8, 40, 0.9, 100, []
          );
          if (!suggestion.startsWith('Error:')) {
            this.emit('assistant_message', { message: suggestion, sender: 'Call Flow Manager' });
          }
        } catch (e) {
          this.log('Error generating call flow suggestion:', e);
        }
      }

      async generateContent(contextMessages, systemInstruction, temperature, topK, topP, maxOutputTokens, stopSequences) {
        this.emit('processing_started');
        const headers = { 'Content-Type': 'application/json' };
        const contents = JSON.parse(JSON.stringify(contextMessages));

        if (systemInstruction) {
          if (contents.length > 0 && contents[0].role === 'user') {
            contents[0].parts[0].text = systemInstruction + "\n\n" + contents[0].parts[0].text;
          } else if (contents.length === 0) {
            contents.push({ role: 'user', parts: [{ text: systemInstruction }] });
          } else {
            contents.unshift({ role: 'user', parts: [{ text: systemInstruction }] });
          }
        }

        const body = JSON.stringify({
          contents,
          generationConfig: { temperature, topK, topP, maxOutputTokens, stopSequences }
        });

        this.log("Request to Gemini:", body);

        try {
          const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyAuGsOgCCzlSBvpcelKWcZXBf1FXFx-zMg`, {
            method: 'POST',
            headers,
            body
          });

          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
          }

          const data = await response.json();
          this.log("Response from Gemini:", data);
          return data.candidates && data.candidates.length > 0 ? data.candidates[0].content.parts[0].text : "No response from AI.";
        } catch (error) {
          this.log('Error generating content:', error);
          this.emit('error', { type: 'api_error', message: error.message });
          return "Error: Could not get a response from AI.";
        }
      }

      speak(text, gender = this.config.voiceGender) {
        return new Promise((resolve, reject) => {
          if (this.state.isTypingManually) {
            this.log('User typing manually - skipping speech synthesis');
            resolve();
            return;
          }
          if (this.state.isListening) {
            this.stopListening();
          }
          if (this.synthesis.speaking) {
            this.synthesis.cancel();
          }

          this.currentUtterance = new SpeechSynthesisUtterance(text);
          this.currentUtterance.voice = this.selectedVoice;
          this.currentUtterance.rate = this.config.speechRate;
          this.currentUtterance.pitch = this.config.speechPitch;
          this.currentUtterance.volume = this.config.speechVolume;

          this.currentUtterance.onstart = () => {
            this.state.isSpeaking = true;
            this.log(`Started speaking: "${text}"`);
            this.emit('speaking_started', { text });
          };

          this.currentUtterance.onend = () => {
            this.state.isSpeaking = false;
            this.state.lastSpeechEndTime = performance.now();
            this.log('Finished speaking');
            this.emit('speaking_finished', { text });
            if (this.state.conversationActive && !this.state.isTypingManually) {
              setTimeout(() => this.startListening(), 500);
            }
            resolve();
          };

          this.currentUtterance.onerror = (event) => {
            this.state.isSpeaking = false;
            this.state.lastSpeechEndTime = performance.now();
            this.log(`Speech synthesis error: ${event.error}`);
            this.emit('speaking_error', { error: event.error });
            reject(new Error(event.error));
          };

          this.synthesis.speak(this.currentUtterance);
        });
      }

      stopSpeaking() {
        if (this.synthesis.speaking) {
          this.synthesis.cancel();
          this.state.isSpeaking = false;
          this.state.lastSpeechEndTime = performance.now();
          this.log('Stopped speaking');
          this.emit('speaking_stopped');
        }
      }

      selectVoice() {
        const voices = this.synthesis.getVoices();
        let preferredVoice = voices.find(voice => {
          const name = voice.name.toLowerCase();
          if (this.config.voiceGender === 'female') {
            return name.includes('female') || name.includes('woman') || name.includes('zira') || name.includes('samantha');
          } else {
            return name.includes('male') || name.includes('man') || name.includes('david');
          }
        });
        if (!preferredVoice && voices.length > 0) {
          preferredVoice = voices.find(v => v.lang.includes('en-US')) || voices[0];
        }
        this.selectedVoice = preferredVoice || null;
        this.log(`Selected voice: ${this.selectedVoice ? this.selectedVoice.name : 'none'}`);
      }

      getRandomScenario() {
        if (!this.scenarios || !Array.isArray(this.scenarios) || this.scenarios.length === 0) {
          this.log("Scenarios data is not available or is empty. Using default scenario.");
          return {
            customerName: "Default Customer",
            initialCustomerComplaint: "I have an issue with my service.",
            customerGender: "male",
            customerTemperature: 0.7,
            customerTopK: 40,
            customerTopP: 0.8,
            customerMaxOutputTokens: 100
          };
        }
        return this.scenarios[Math.floor(Math.random() * this.scenarios.length)];
      }

      delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
      }

      log(msg, ...args) {
        if (this.config.debug) {
          console.log(`[VoiceController] ${msg}`, ...args);
        }
      }

      emit(eventName, detail) {
        this.dispatchEvent(new CustomEvent(eventName, { detail }));
      }
    }

    // === UI Logic ===
    const vc = new VoiceController({ debug: true, silenceDelay: 2000 });

    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const sendBtn = document.getElementById('sendBtn');
    const chat = document.getElementById('chat');
    const manualInput = document.getElementById('manual-input');
    const statusText = document.getElementById('statusText');
    const statusIndicator = document.getElementById('statusIndicator');
    const silenceTimerElem = document.getElementById('silenceTimer');
    const silenceDelaySelect = document.getElementById('silenceDelay');
    const qualityFeedbackPanel = document.getElementById('quality-feedback-panel');
    const s1Phase = document.getElementById('s1-phase');
    const s2Phase = document.getElementById('s2-phase');
    const s3Phase = document.getElementById('s3-phase');
    const s4Phase = document.getElementById('s4-phase');
    const s4Phases = { 'S1': s1Phase, 'S2': s2Phase, 'S3': s3Phase, 'S4': s4Phase };
    const genericModal = document.getElementById('genericModal');
    const modalTitle = document.getElementById('modalTitle');
    const modalBody = document.getElementById('modalBody');
    const closeModalBtn = document.getElementById('closeModalBtn');
    const modalSaveBtn = document.getElementById('modalSaveBtn');
    const modalCancelBtn = document.getElementById('modalCancelBtn');

    function addMessage(text, sender, senderName = '') {
      const messages = chat.querySelector('.messages');
      const div = document.createElement('div');
      div.className = `message ${sender}`;
      if (senderName) {
        const nameSpan = document.createElement('span');
        nameSpan.className = 'sender-name';
        nameSpan.textContent = senderName;
        div.appendChild(nameSpan);
      }
      const textNode = document.createTextNode(text);
      div.appendChild(textNode);
      messages.appendChild(div);
      chat.scrollTop = chat.scrollHeight;
    }

    function addQualityFeedback(score, comment, details = {}) {
      const div = document.createElement('div');
      div.classList.add('quality-comment');
      if (score >= 80) {
        div.classList.add('good');
      } else if (score < 60) {
        div.classList.add('bad');
      }
      div.innerHTML = `<strong>Score: ${score}/100</strong><br>${comment}`;
      const infoBtn = document.createElement('button');
      infoBtn.className = 'quality-info-btn';
      infoBtn.innerHTML = 'üí°';
      infoBtn.title = 'Click for more details';
      infoBtn.onclick = () => showQualityDetails(details);
      div.appendChild(infoBtn);
      qualityFeedbackPanel.appendChild(div);
      qualityFeedbackPanel.scrollTop = qualityFeedbackPanel.scrollHeight;
    }

    function showQualityDetails(details) {
      let detailHtml = `<h4>Feedback Details:</h4>`;
      if (details.s4Phase) {
        detailHtml += `<p><strong>S4 Phase:</strong> ${details.s4Phase}</p>`;
      }
      if (details.confidence !== undefined) {
        detailHtml += `<p><strong>Speech Confidence:</strong> ${(details.confidence * 100).toFixed(1)}%</p>`;
      }
      if (details.deadAir !== undefined) {
        detailHtml += `<p><strong>Dead Air Duration:</strong> ${details.deadAir.toFixed(2)}s</p>`;
      }
      if (details.reasoning) {
        detailHtml += `<p><strong>AI Reasoning:</strong> ${details.reasoning}</p>`;
      }
      if (details.suggestions) {
        detailHtml += `<p><strong>Suggestions:</strong> ${details.suggestions}</p>`;
      }
      showModal('Quality Feedback Details', detailHtml, null, true);
    }

    function updateS4Progress(phase) {
      Object.values(s4Phases).forEach(el => {
        el.classList.remove('active', 'completed');
      });

      let foundActive = false;
      for (const s4Key in s4Phases) {
        if (s4Key === phase) {
          s4Phases[s4Key].classList.add('active');
          foundActive = true;
          vc.state.currentS4Phase = s4Key;
        } else if (!foundActive) {
          s4Phases[s4Key].classList.add('completed');
        }
      }
    }

    function resetS4Progress() {
      Object.values(s4Phases).forEach(el => {
        el.classList.remove('active', 'completed');
      });
      s4Phases['S1'].classList.add('active');
      vc.state.currentS4Phase = 'S1';
    }

    const settingsSchema = [
      { id: 'customerTemperature', label: 'Customer AI Temperature (0.0-1.0)', type: 'number', min: 0.0, max: 1.0, step: 0.1, key: 'customerTemperature' },
      { id: 'customerTopK', label: 'Customer AI Top K', type: 'number', min: 1, max: 100, step: 1, key: 'customerTopK' },
      { id: 'customerTopP', label: 'Customer AI Top P (0.0-1.0)', type: 'number', min: 0.0, max: 1.0, step: 0.1, key: 'customerTopP' },
      { id: 'customerMaxOutputTokens', label: 'Customer AI Max Output Tokens', type: 'number', min: 1, max: 2048, step: 1, key: 'customerMaxOutputTokens' },
      { id: 'speechVolume', label: 'Speech Volume (0.0-1.0)', type: 'number', min: 0.0, max: 1.0, step: 0.1, key: 'speechVolume' },
      { id: 'voiceGender', label: 'Voice Gender', type: 'select', options: [{value: 'female', label: 'Female'}, {value: 'male', label: 'Male'}], key: 'voiceGender' }
    ];

    const personaSchema = [
      { id: 'customerPersona', label: 'Customer AI Persona', type: 'textarea', key: 'customerPersona' },
      { id: 'qualityAssistantPersona', label: 'Quality Assistant Persona', type: 'textarea', key: 'qualityAssistantPersona' },
      { id: 'flowManagerPersona', label: 'Call Flow Manager Persona', type: 'textarea', key: 'flowManagerPersona' }
    ];

    function showModal(title, schema, currentValues, hideActions = false) {
      modalTitle.textContent = title;
      modalBody.innerHTML = '';

      if (typeof schema === 'string') {
        modalBody.innerHTML = schema;
      } else {
        schema.forEach(field => {
          const label = document.createElement('label');
          label.textContent = field.label;
          let input;

          if (field.type === 'textarea') {
            input = document.createElement('textarea');
            input.rows = 4;
            input.value = currentValues ? currentValues[field.key] : '';
          } else if (field.type === 'select') {
            input = document.createElement('select');
            field.options.forEach(opt => {
              const option = document.createElement('option');
              option.value = opt.value;
              option.textContent = opt.label;
              if (currentValues && currentValues[field.key] === opt.value) {
                option.selected = true;
              }
              input.appendChild(option);
            });
          } else {
            input = document.createElement('input');
            input.type = field.type;
            if (field.type === 'number') {
              input.min = field.min;
              input.max = field.max;
              input.step = field.step;
              input.value = currentValues ? currentValues[field.key] : '';
            } else {
              input.value = currentValues ? currentValues[field.key] : '';
            }
          }
          input.id = field.id;
          label.appendChild(input);
          modalBody.appendChild(label);
        });
      }

      genericModal.classList.add('show');
      modalSaveBtn.style.display = hideActions ? 'none' : '';
      modalCancelBtn.style.display = hideActions ? 'none' : '';
    }

    function hideModal() {
      genericModal.classList.remove('show');
    }

    closeModalBtn.addEventListener('click', hideModal);
    modalCancelBtn.addEventListener('click', hideModal);

    modalSaveBtn.addEventListener('click', () => {
      const title = modalTitle.textContent;
      if (title.includes('Settings')) {
        settingsSchema.forEach(field => {
          const input = document.getElementById(field.id);
          if (input) {
            let value = field.type === 'number' ? parseFloat(input.value) : input.value;
            if (field.key === 'speechVolume') {
              vc.config.speechVolume = value;
            } else if (field.key === 'voiceGender') {
              vc.config.voiceGender = value;
              vc.selectVoice();
            } else if (vc.state.currentScenario && vc.state.currentScenario.hasOwnProperty(field.key)) {
              vc.state.currentScenario[field.key] = value;
            }
          }
        });
        vc.log('Settings saved. Current Scenario:', vc.state.currentScenario);
      } else if (title.includes('Persona')) {
        personaSchema.forEach(field => {
          const input = document.getElementById(field.id);
          if (input) {
            if (field.key === 'customerPersona') {
              vc.customerPersona = input.value;
            } else if (field.key === 'qualityAssistantPersona') {
              vc.qualityAssistantPersona = input.value;
            } else if (field.key === 'flowManagerPersona') {
              vc.flowManagerPersona = input.value;
            }
          }
        });
        vc.log('Personas saved.');
      }
      hideModal();
    });

    document.getElementById('open-settings').addEventListener('click', () => {
      showModal('Adjust Settings', settingsSchema, {
        customerTemperature: vc.state.currentScenario ? vc.state.currentScenario.customerTemperature : 0.7,
        customerTopK: vc.state.currentScenario ? vc.state.currentScenario.customerTopK : 40,
        customerTopP: vc.state.currentScenario ? vc.state.currentScenario.customerTopP : 0.8,
        customerMaxOutputTokens: vc.state.currentScenario ? vc.state.currentScenario.customerMaxOutputTokens : 100,
        speechVolume: vc.config.speechVolume,
        voiceGender: vc.config.voiceGender
      });
    });

    document.getElementById('open-persona').addEventListener('click', () => {
      showModal('Adjust Personas', personaSchema, {
        customerPersona: vc.customerPersona,
        qualityAssistantPersona: vc.qualityAssistantPersona,
        flowManagerPersona: vc.flowManagerPersona
      });
    });

    // Button events
    startBtn.onclick = () => {
      vc.startConversation();
      startBtn.disabled = true;
      stopBtn.disabled = false;
      sendBtn.disabled = true;
      statusText.textContent = 'Listening...';
      statusIndicator.className = 'status-indicator listening';
      manualInput.value = '';
      manualInput.focus();
    };

    stopBtn.onclick = () => {
      vc.stopConversation();
      startBtn.disabled = false;
      stopBtn.disabled = true;
      sendBtn.disabled = true;
      statusText.textContent = 'Stopped';
      statusIndicator.className = 'status-indicator';
      manualInput.value = '';
    };

    sendBtn.onclick = () => {
      const message = manualInput.value.trim();
      if (message) {
        const confidence = 1.0;
        const deadAir = (performance.now() - vc.state.lastSpeechEndTime) / 1000;
        vc.processUserMessage(message, confidence, deadAir);
        manualInput.value = '';
        vc.state.isTypingManually = false;
        sendBtn.disabled = true;
      }
    };

    silenceDelaySelect.onchange = (e) => {
      vc.config.silenceDelay = parseInt(e.target.value, 10);
      silenceTimerElem.textContent = `Auto-send in ${e.target.value / 1000}s`;
    };

    // Manual input events
    manualInput.addEventListener('input', () => {
      vc.state.isTypingManually = true;
      vc.stopListening();
      vc.stopSpeaking();
      sendBtn.disabled = !manualInput.value.trim();
    });

    manualInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        const message = manualInput.value.trim();
        if (message) {
          const confidence = 1.0;
          const deadAir = (performance.now() - vc.state.lastSpeechEndTime) / 1000;
          vc.processUserMessage(message, confidence, deadAir);
          manualInput.value = '';
          vc.state.isTypingManually = false;
          sendBtn.disabled = true;
        }
      }
    });

    // Transcript updates
    vc.addEventListener('transcription_update', (e) => {
      const { text } = e.detail;
      if (!vc.state.isTypingManually) {
        manualInput.value = text || '';
      }
      sendBtn.disabled = !manualInput.value.trim();
    });

    vc.addEventListener('user_message', (e) => {
      addMessage(e.detail.message, 'user', 'Agent');
    });

    vc.addEventListener('assistant_message', (e) => {
      addMessage(e.detail.message, 'assistant', e.detail.sender);
    });

    vc.addEventListener('quality_feedback', (e) => {
      addQualityFeedback(e.detail.score, e.detail.comment, e.detail.details);
      updateS4Progress(e.detail.details.s4Phase || vc.state.currentS4Phase);
    });

    vc.addEventListener('listening_started', () => {
      statusText.textContent = 'Listening...';
      statusIndicator.className = 'status-indicator listening';
      sendBtn.disabled = true;
    });

    vc.addEventListener('listening_stopped', () => {
      statusText.textContent = 'Paused';
      statusIndicator.className = 'status-indicator';
    });

    vc.addEventListener('speaking_started', () => {
      statusText.textContent = 'Speaking...';
      statusIndicator.className = 'status-indicator speaking';
      sendBtn.disabled = true;
    });

    vc.addEventListener('speaking_finished', () => {
      statusText.textContent = 'Listening...';
      statusIndicator.className = 'status-indicator listening';
      sendBtn.disabled = !manualInput.value.trim();
    });

    vc.addEventListener('silence_timer_reset', () => {
      silenceTimerElem.classList.add('active');
    });

    vc.addEventListener('silence_detected', () => {
      silenceTimerElem.classList.remove('active');
    });

    vc.addEventListener('conversation_started', (e) => {
      chat.querySelector('.messages').innerHTML = '';
      qualityFeedbackPanel.innerHTML = '<div class="quality-comment">Feedback will appear here after each of your responses.</div>';
      resetS4Progress();
      addMessage(
        `System: Starting new call with ${e.detail.scenario.customerName} and their initial complaint is: "${e.detail.scenario.initialCustomerComplaint}". Please begin the call.`,
        'assistant',
        'System'
      );
    });

    vc.addEventListener('error', (e) => {
      addMessage(`Error: ${e.detail.message}`, 'assistant', 'System');
      statusText.textContent = `Error: ${e.detail.message}`;
      statusIndicator.className = 'status-indicator';
    });

    document.addEventListener('DOMContentLoaded', () => {
      const complaintsScript = document.querySelector('script[src="complaints.js"]');
      if (complaintsScript) {
        complaintsScript.addEventListener('error', () => {
          vc.log("Failed to load complaints.js. Using fallback scenario.");
        });
        complaintsScript.addEventListener('load', () => {
          vc.log("complaints.js loaded successfully.");
          vc.scenarios = window.COMPLAINTS_DATA || vc.scenarios;
          vc.startConversation();
        });
      } else {
        vc.log("complaints.js script tag not found.");
        vc.startConversation();
      }
    });
  </script>
</body>
</html>
